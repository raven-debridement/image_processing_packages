#!/usr/bin/env python

import roslib
roslib.load_manifest('raven_pose_estimator')
import rospy

import Util

import cv

from sensor_msgs.msg import Image, CameraInfo
from stereo_msgs.msg import DisparityImage
from geometry_msgs.msg import PointStamped
from visualization_msgs.msg import Marker
import cv_bridge

import tfx

RED_LOWER_HSV = cv.Scalar(0, 120, 50)
RED_UPPER_HSV = cv.Scalar(6, 255, 255)
LOWERHSV = RED_LOWER_HSV
UPPERHSV = RED_UPPER_HSV
LOWERHSV2 = cv.Scalar(170, 120, 50)
UPPERHSV2 = cv.Scalar(180, 255, 255)

class DisparitySegmenter():
    def __init__(self, left_camera, right_camera, disparity, topic):
        self.image = {'l': None, 'r': None}
        self.info = {'l': None, 'r': None}
        self.bridge = cv_bridge.CvBridge()
        self.calculating = False
        self.foundCentroidInLeft = False

        self.disparityImg = None
        self.hsvImg = cv.CreateImage((1280, 960), 8, 3)
        self.threshImg = cv.CreateImage((1280, 960), 8, 1)
        self.threshImg2 = cv.CreateImage((1280, 960), 8, 1)

        self.pointpub = rospy.Publisher(topic, PointStamped)
        self.markerpub = rospy.Publisher(topic+'_marker', Marker)

        rospy.Subscriber(left_camera + "/camera_info", CameraInfo, self.leftInfoCallback)
        rospy.Subscriber(right_camera + "/camera_info", CameraInfo, self.rightInfoCallback)
        rospy.Subscriber(disparity, DisparityImage, self.disparityCallback)

    def disparityCallback(self, msg):
        image = self.bridge.imgmsg_to_cv(msg.image, "mono8")
        self.disparityImg = image
        self.minDisparity = msg.min_disparity

    def leftInfoCallback(self, msg):
        if self.info['l']:
            return
        self.info['l'] = msg
        rospy.Subscriber(left_camera + "/image_rect_color", Image, self.leftImageCallback, queue_size = 1)

    def rightInfoCallback(self, msg):
        if self.info['r']:
            return
        self.info['r'] = msg

    def leftImageCallback(self, msg):
        if not self.disparityImg:
            return

        # Threshold the image
        self.image['l'] = self.process(msg, 'l')
        image = self.image['l']
        # Uncomment to show the thresholded image
        # Util.showImage(image, "threshed")

        # find contours
        storage = cv.CreateMemStorage(0)
        contours = cv.FindContours(image, storage, mode=cv.CV_RETR_LIST, method=cv.CV_CHAIN_APPROX_SIMPLE)
        if len(contours) == 0:
            return

        # Find the first contour with length > 60 and get the center
        color = cv.Scalar(255)
        holeColor = cv.Scalar(255)
        maxLevel = 1
        thickness = cv.CV_FILLED
        found = False
        while contours is not None:
            contour = contours[:]
            contours = contours.h_next()
            if len(contour) < 60:
                continue
            found = True
            cv.FillPoly(image, [contour], color)
            #found, self.xClose, self.yClose, xCentroid, yCentroid = Util.find_centroid(image)
            self.xClose, self.yClose = self.getCenterOfMass(contour)
            break
        Util.showImage(image, "left")
        #cv.DrawContours(image, contours, color, holeColor, maxLevel, thickness)

        if not found:
            return

        # Search for the closest disparity pixel by searching in a square with larger and larger radius
        disparity = -1000
        for radius in range(50):
            x, y, disparity = self.getBoxDisparity(radius, image)
            if disparity > self.minDisparity:
                break

        # Use disparity value to find 3d location of point
        if disparity > self.minDisparity:
            point = Util.convertStereo(x, y , disparity, self.info)
            self.pointpub.publish(point)

            marker = Util.createMarker(tfx.pose(point).msg.PoseStamped(),1)
            self.markerpub.publish(marker)

    def getCenterOfMass(self, image):
        """
        Gets the center of mass of an image or contour.
        """

        binaryImage = True
        moments = cv.Moments(image, binaryImage)
        total = float(cv.GetSpatialMoment(moments, 0, 0))
        xavg = float(cv.GetSpatialMoment(moments, 1, 0))
        yavg = float(cv.GetSpatialMoment(moments, 0, 1))
        return int(xavg / total), int(yavg / total)

    def getBoxDisparity(self, radius, image):
        """
        Gets a disparity value in a square of radius radius, or None if no disparity value can be found.
        """

        dispImg = self.disparityImg
        
        # check left edge
        x = self.xClose - radius
        for y in range(self.yClose - radius, self.yClose + radius + 1):
            d = self.getDisparity(x, y, image, dispImg)
            if d > self.minDisparity:
                return (x, y, d)
                
        # check top edge
        y = self.yClose + radius
        for x in range(self.xClose - radius, self.xClose + radius + 1):
            d = self.getDisparity(x, y, image, dispImg)
            if d > self.minDisparity:
                return (x, y, d)

        # check right edge
        x = self.xClose + radius
        for y in range(self.yClose - radius, self.yClose + radius + 1):
            d = self.getDisparity(x, y, image, dispImg)
            if d > self.minDisparity:
                return (x, y, d)

        return 0,0,0

        # check bottom edge
        y = self.yClose - radius
        for x in range(self.xClose - radius, self.xClose + radius + 1):
            d = self.getDisparity(x, y, image, dispImg)
            if d > self.minDisparity:
                return (x, y, d)

    def getDisparity(self, x, y, image, dispImg):
        if image[y, x] > 0:
            return cv.GetReal2D(dispImg, y, x)

    def process(self, msg, arm):
        """
        Threshold the image.
        """

        image = self.bridge.imgmsg_to_cv(msg, "bgr8")

        if arm == 'l':
            threshImg = Util.threshold(image, self.hsvImg, self.threshImg, LOWERHSV, UPPERHSV)
            threshImg2 = Util.threshold(image, self.hsvImg, self.threshImg2, LOWERHSV2, UPPERHSV2)
            cv.Or(threshImg, threshImg2, threshImg)

            return threshImg

if __name__ == '__main__':
    rospy.init_node('disparity_segmenter')
    left_camera = 'left'
    right_camera = 'right'
    segmenter = DisparitySegmenter(left_camera, right_camera, '/disparity', 'foam_points')
    rospy.spin()
