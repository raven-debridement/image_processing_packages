#!/usr/bin/env python

# Import required Python code.
import roslib
roslib.load_manifest('raven_pose_estimator')
import rospy

import cv
import cv2
import numpy
import math
from std_msgs.msg import String
from sensor_msgs.msg import Image, CameraInfo
from cv_bridge import CvBridge, CvBridgeError
from geometry_msgs.msg import Point, PointStamped
import tf
import image_geometry

import message_filters
from threading import Lock

# adapted and adjusted from Greg Kahn's code (ImageProcessing.py)

class GripperSegmenter():
    def __init__(self, left_camera, right_camera):
        
        self.leftInfo = self.rightInfo = None

        self.foundColorLeft = False
        self.foundColorRight = False

        self.listener = tf.TransformListener()
        self.outputFrame = 'base_link'        
        self.bridge = CvBridge()
        rospy.Subscriber('%s/image_rect_color'%left_camera, Image, self.leftImageCallback)
        rospy.Subscriber('%s/image_rect_color'%right_camera, Image, self.rightImageCallback)
        rospy.Subscriber('%s/camera_info'%left_camera, CameraInfo, self.leftInfoCallback)
        rospy.Subscriber('%s/camera_info'%right_camera, CameraInfo, self.rightInfoCallback)

    def convertStereo(self, u, v, disparity):
        """
        Converts two pixel coordinates u and v along with the disparity to give PointStamped       
        """
        stereoModel = image_geometry.StereoCameraModel()
        stereoModel.fromCameraInfo(self.leftInfo, self.rightInfo)
        (x,y,z) = stereoModel.projectPixelTo3d((u,v), disparity)
        
        cameraPoint = PointStamped()
        cameraPoint.header.frame_id = self.leftInfo.header.frame_id
        cameraPoint.header.stamp = rospy.Time.now()
        cameraPoint.point = Point(x,y,z)

        self.listener.waitForTransform(self.outputFrame, cameraPoint.header.frame_id, rospy.Time.now(), rospy.Duration(4.0))
        outputPoint = self.listener.transformPoint(self.outputFrame, cameraPoint)
        return outputPoint
    
    def leftInfoCallback(self, info):
        self.leftInfo = info

    def rightInfoCallback(self, info):
        self.rightInfo = info

    def leftImageCallback(self, image):
        colorImg, self.foundColorLeft, self.xyCloseLeft, self.xyCentroidLeft = self.process(image)
        #cv.ShowImage('Left Viewer', colorImg)
        #cv.WaitKey(3)

    def rightImageCallback(self, image):
        colorImg, self.foundColorRight, self.xyCloseRight, self.xyCentroidRight = self.process(image)
        #cv.ShowImage('Right Viewer', colorImg)
        #cv.WaitKey(3)

    #def process(self, image):
		
        

#takes in an image and returns the centroid of its blob
def findCentroid(image):
	mat = cv.GetMat(image)
	yxCoords = []
	for x in range(mat.width):
	    for y in range(mat.height):
	        if mat[y,x] > 0.0:
	            yxCoords.append((y,x))
	if len(yxCoords) == 0:
	    return                     
	yCentroid = sum([y for y,x in yxCoords])/len(yxCoords)
	xCentroid = sum([x for y,x in yxCoords])/len(yxCoords)
	return (xCentroid, yCentroid)

#takes in an input IplImage and two cv.Scalars for the upper and lower hsv values
#returns a thresholded image
def threshold(inputImage, lowerBound, upperBound):
	hsvImg = cv.CreateImage(cv.GetSize(inputImage), 8, 3)
	cv.CvtColor(inputImage, hsvImg, cv.CV_BGR2HSV)
	threshImg = cv.CreateImage(cv.GetSize(hsvImg), 8, 1)
	cv.InRangeS(hsvImg, lowerBound, upperBound, threshImg)
	return threshImg

#takes in an input binary image and counts number of pixels that are equal to 0
def countPixels(threshImg):
	return cv.CountNonZero(threshImg)

def webcam():	
	color1 = "red"
	red_lower = cv.Scalar(0, 150, 80)
	red_upper = cv.Scalar(10, 255, 200)
	color3 = "green"
	green_lower = cv.Scalar(50, 50, 30)
	green_upper = cv.Scalar(90, 150, 130)
	numBits = 8
	numChannels = 3
	capture = cv.CaptureFromCAM(1)
	while True:
		frame = cv.QueryFrame(capture)
		cv.Smooth(frame, frame, cv.CV_GAUSSIAN, 3, 0)
		thresh = cv.CreateImage(cv.GetSize(frame), 8, 1)
		threshred = threshold(frame, red_lower, red_upper) 
		threshgreen = threshold(frame, green_lower, green_upper)
		intermediate2 = cv.CreateImage(cv.GetSize(frame), 8, 1)
		#cv.Erode(threshgreen, threshgreen, None, 3)
        #cv.Dilate(threshgreen, threshgreen, None, 5) 
		#print "Ratio green to red"
		#print "%d:%d"%(countPixels(threshgreen), countPixels(threshred))
		
		hough = cv.CreateMemStorage()
		edges = cv.CreateImage(cv.GetSize(frame), 8, 1)
		temp = cv.CreateImage(cv.GetSize(frame), 8, 1)
		done = True
		element = 1
		cv.Canny(threshgreen, edges, 0.5, 5.0)
		for i in range(3):
 			cv.Dilate(edges, edges, None, 2)
			cv.Erode(edges, edges, None, 2)
		cv.Add(cv.GetMat(threshgreen), cv.GetMat(threshred), intermediate2)
		lines = cv.HoughLines2(edges, hough, cv.CV_HOUGH_PROBABILISTIC, 1, 1, 1)
		for i in range(len(lines)):
			rho = lines[i][0]
			theta = lines[i][1]
			a = math.cos(theta)
			b = math.sin(theta)
			x0 = a*rho
			y0 = b*rho
			pt1 = (cv.Round(x0 + 1000*(-b)), cv.Round(y0 + 1000*(a)))
			pt2 = (cv.Round(x0 - 1000*(-b)), cv.Round(y0 - 1000*(a)))
			cv.Line( edges, pt1, pt2, cv.Scalar(0,0,255))
		"""matrix = numpy.asarray(cv.GetMat(edges))
		mean, eigenvectors = cv2.PCACompute(matrix)""" #PCA
		"""if mean.any():
			print "mean"
			print mean
			print "eigenvectors"
			print eigenvectors"""
		"""if len(lines) > 0:
			sum_rhos = 0
			sum_thetas = 0
			for rho, theta in lines[0]:
				sum_rhos += rho
				sum_thetas += theta
			avg_rho = sum_rhos/len(lines[0])
			avg_theta = sum_thetas/len(lines[0])
			print "averages"
			print "\tavg rho: %d"%avg_rho
			print "\tavg theta: %d"%avg_theta"""
		cv.ShowImage("Original", frame)
		cv.ShowImage("Threshholded", intermediate2)
		cv.ShowImage("Edges", edges)
		cv.WaitKey(3)

def main():
    rospy.init_node('gripper_estimator')
    left_camera = 'left'
    right_camera = 'right'
    gs = GripperSegmenter(left_camera, right_camera)
    rospy.spin()


if __name__ == '__main__':
    #main()
    #test()
    webcam()
