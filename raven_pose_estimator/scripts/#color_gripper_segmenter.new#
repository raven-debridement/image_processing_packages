#!/usr/bin/env python

# Import required Python code.
import roslib
roslib.load_manifest('raven_pose_estimator')
import rospy

import cv
import cv2
import numpy as np
from scipy import linalg
import math
from std_msgs.msg import String
from sensor_msgs.msg import Image, CameraInfo
import cv_bridge
from geometry_msgs.msg import Point, PointStamped
import tf
import image_geometry
import time

import message_filters
from threading import Lock

import tf.transformations as tft
import tfx

import code

# adapted and adjusted from Greg Kahn's code (ImageProcessing.py)

########################################
#             CONSTANTS                #
########################################

#TRANSLATION_R2L = (-0.05137, 0, 0.00136) #FIXME stick in translation and rotation matrices
#ROTATION_R2L = (0, -0.108380311, 0)
TRANSLATION_R2L = (-0.129296, 0, 0.00136124)
ROTATION_R2L = (0,0.104719755,0)
ORANGE_LOWER = cv.Scalar( 1, 150, 100)
ORANGE_UPPER = cv.Scalar( 5, 255, 255)
BLUE_LOWER = cv.Scalar(108,100, 100)
BLUE_UPPER = cv.Scalar(120,255, 255)

########################################
#     3D GEOMETRY HELPER METHODS       #
########################################

def flip_origin(point, height):
    x = point[0]
    y = point[1]
    result_x = x
    result_y = height-y
    return (result_x, result_y)

def flip_line(line, height):
    (x1, y1) = flip_origin((line[0], line[1]), 1280)
    (x2, y2) = flip_origin((line[2], line[3]), 1280)
    return (x1, y1, x2, y2)

def normalize(self, vector):
    norm = ((vector[0])**2+(vector[1])**2+(vector[2])**2)**0.5
    normalized = []
    for i in range(0, len(vector)):
	normalized.append(vector[i]/norm)
    return normalized
  
def cross_product(self, v1, v2):
    x = v1[1]*v2[2]-v1[2]*v2[1]
    y = -(v1[0]*v2[2]-v2[0]*v1[2])
    z = v1[0]*v2[1]-v2[0]*v1[1]
    return (x,y,z)

def angleBetweenQuaternions(quat0, quat1):
    """
    Returns angle between quat0 and quat1 in degrees
    """
    q0 = np.array(quat0)
    q1 = np.array(quat1)
    theta = math.acos(2*np.dot(q0,q1)**2 - 1)
    theta = theta*(180.0/math.pi)
    return theta

def invert_vector(v):
    return [-x for x in v]

def has_neighbor(point, point_list):
    if (point[0]+1, point[1]) in point_list:
	return True
    elif (point[0]-1, point[1]) in point_list:
	return True
    elif (point[0], point[1]+1) in point_list:
	return True
    elif (point[0], point[1]-1) in point_list:
	return True
    elif (point[0]+1, point[1]+1) in point_list:
	return True
    elif (point[0]+1, point[1]-1) in point_list:
	return True
    elif (point[0]-1, point[1]+1) in point_list:
	return True
    elif (point[0]-1, point[1]-1) in point_list:
	return True
    else:
	return False

def find_centroid(yxCoords):
    yCentroid = sum([y for y,x in yxCoords])/len(yxCoords)
    xCentroid = sum([x for y,x in yxCoords])/len(yxCoords)        
    # find nearest color pixel to centroid (based on euclidean distance)
    distFromCentroid = [((y-yCentroid)**2 + (x-xCentroid)**2)**.5 for y,x in yxCoords]
    yClose, xClose = yxCoords[distFromCentroid.index(min(distFromCentroid))]
    return (xCentroid, yCentroid)

def order_points(p1, p2):
    if p1[1] > p2[1]:
	return p1,p2
    elif p1[1] < p2[1]:
	return p2,p1
    else:
	return p1,p2

def find_endpoints(threshImg):
    lower_pt = upper_pt = None
    mat = cv.GetMat(threshImg)
    yxCoords = []
    for x in range(mat.width):
	for y in range(mat.height):
	    if mat[y,x] > 0.0:
		yxCoords.append((y,x))
    # check if any color is present
    if len(yxCoords) == 0:
	return (lower_pt, upper_pt, False)
    else: 
	points = [[]]
	for point in yxCoords:
	    for point_list in points:
		had_neighbor = False
 	        if has_neighbor(point, point_list):
		    point_list.append(point)
		    had_neighbor == True
	    if had_neighbor == False:
		points.append([point])
	centroids = []
	for point_list in points:
	    if len(point_list) > 0:
  	        centroids.append(find_centroid(point_list))
	#print "CENTROIDS: "+str(centroids)
	upper_pt, lower_pt = order_points(centroids[0], centroids[len(centroids)-1])
	print "UPPER POINT: "+str(upper_pt)
	print "LOWER POINT: "+str(lower_pt)
	return (lower_pt, upper_pt, True)	 	    

########################################
#    IMAGE-RELATED HELPER METHODS      #
########################################

""" thresholds an image for a certain range of hsv values """ #FIXME: does eroding and dilating cause a big performance hit?
def threshold(image, hsvImg, threshImg, lowerHSV, upperHSV):
    cv.Smooth(image, image, cv.CV_GAUSSIAN, 3, 0)
    cv.CvtColor(image, hsvImg, cv.CV_BGR2HSV) 
    cv.InRangeS(hsvImg, lowerHSV, upperHSV, threshImg)
    cv.Erode(threshImg, threshImg, None, 1)    
    cv.Dilate(threshImg, threshImg, None, 1)
    return threshImg

##################
#   MAIN CLASS   #
##################

class ColorSegmenter():
    def __init__(self, left_camera, right_camera):
        self.leftInfo = self.rightInfo = None
        self.foundColorLeft = False
        self.foundColorRight = False
        self.listener = tf.TransformListener()
	self.bridge = cv_bridge.CvBridge()
        rospy.Subscriber('/stereo/%s/image_rect_color'%left_camera, Image, self.leftImageCallback)
        rospy.Subscriber('/stereo/%s/image_rect_color'%right_camera, Image, self.rightImageCallback)
        rospy.Subscriber('/stereo/%s/camera_info'%left_camera, CameraInfo, self.leftInfoCallback)
        rospy.Subscriber('/stereo/%s/camera_info'%right_camera, CameraInfo, self.rightInfoCallback)
	self.left_orange_found = False
	self.left_blue_found = False
	self.right_orange_found = False
	self.right_blue_found = False
	self.prev_quat = None
	self.blue_left_lower_pt = None
	self.blue_left_upper_pt = None
	self.blue_right_lower_pt = None
	self.blue_right_upper_pt = None
	self.orange_left_lower_pt = None
	self.orange_left_upper_pt = None
	self.orange_right_lower_pt = None
	self.orange_right_upper_pt = None
    
    ################################
    #   SUBSCRIBER BOUND METHODS   #
    ################################
    def leftInfoCallback(self, info):
	""" saves the info for the left camera	"""
        self.leftInfo = info

    def rightInfoCallback(self, info):
	""" saves the info for the right camera	"""
        self.rightInfo = info

    def leftImageCallback(self, image):
	""" """
	self.process(image, "left")
	self.handleBoth()

    def rightImageCallback(self, image):
	""" """
	self.process(image, "right")
	self.handleBoth()

    def handleBoth(self):
	""" returns the unit vector corresponding to the orientation of the colored tape """
	#found = (self.blue_left_lower_pt != None and self.blue_right_lower_pt != None and self.blue_left_upper_pt != None and self.blue_right_upper_pt != None and self.orange_left_lower_pt != None and self.orange_right_lower_pt != None and self.orange_left_upper_pt != None and self.orange_right_upper_pt != None)
	found = self.left_orange_found and self.left_blue_found and self.right_orange_found and self.left_orange_found
	if found:
	    blue_lower_pt = self.convertStereo(self.blue_left_lower_pt[0], self.blue_left_lower_pt[1], math.fabs(self.blue_left_lower_pt[0] - self.blue_right_lower_pt[0]))
	    blue_upper_pt = self.convertStereo(self.blue_left_upper_pt[0], self.blue_left_upper_pt[1], math.fabs(self.blue_left_upper_pt[0] - self.blue_right_upper_pt[0]))
	    orange_lower_pt = self.convertStereo(self.orange_left_lower_pt[0], self.orange_left_lower_pt[1], math.fabs(self.orange_left_lower_pt[0] - self.orange_right_lower_pt[0]))
	    orange_upper_pt = self.convertStereo(self.orange_left_upper_pt[0], self.orange_left_lower_pt[1], math.fabs(self.orange_left_upper_pt[0] - self.orange_right_upper_pt[0]))
	    print "ENDPOINTS"
	    print blue_lower_pt
	    print blue_upper_pt
	    print orange_lower_pt
	    print orange_upper_pt
	    blue_vector = (blue_lower_pt, blue_upper_pt)
	    orange_vector = (orange_lower_pt, orange_upper_pt)
	    quat = self.get_orientation_from_lines(blue_vector, orange_vector)
	    print "yaw pitch roll"
	    print tfx.tb_angles(quat)

    ##############################
    #       HELPER METHODS       #
    ############################## 
   
    def process(self, image, flag):
	"""
	thresholds the image for a certain hsv range and returns the coordinates of the centroid, 
	and the coordinates of the closest point to the centroid
	"""
	cv_image = self.bridge.imgmsg_to_cv(image, "bgr8")
	hsvImg = cv.CreateImage((1280,960),8,3)
	orangeThreshImg = cv.CreateImage((1280,960),8,1)
	orangeThreshImg = threshold(cv_image, hsvImg, orangeThreshImg, ORANGE_LOWER, ORANGE_UPPER)
	blueThreshImg = cv.CreateImage((1280,960),8,1)
	blueThreshImg = threshold(cv_image, hsvImg, blueThreshImg, BLUE_LOWER, BLUE_UPPER)
	if flag=="left":
	    self.blue_left_lower_pt, self.blue_left_upper_pt, self.left_blue_found = find_endpoints(blueThreshImg)
	    self.orange_left_lower_pt, self.orange_left_upper_pt, self.left_orange_found = find_endpoints(orangeThreshImg)
        elif flag=="right":
	    self.blue_right_lower_pt, self.blue_right_upper_pt, self.right_blue_found = find_endpoints(blueThreshImg)
	    self.orange_right_lower_pt, self.orange_right_upper_pt, self.right_orange_found = find_endpoints(orangeThreshImg)

    def get_orientation_from_lines(self, v0, v1):
        """
        v0 and v1 are vectors representing two lines
        that are KNOWN to be in the same plane
        """
        v0, v1 = np.array(v0), np.array(v1)
        v0 = v0 / np.linalg.norm(v0) 
        v1 = v1 / np.linalg.norm(v1) 
        n = np.cross(v0, v1)
	rotMat = np.vstack((v0, v1, n)).T
	matrix = rotMat
	matrix = linalg.orth(rotMat)
        tbRot = tfx.tb_angles(matrix)
        quat = tbRot.quaternion
        return list(quat)

    def convertStereo(self, u, v, disparity):
        """
        Converts two pixel coordinates u and v along with the disparity to give PointStamped       
        """
        stereoModel = image_geometry.StereoCameraModel()
        stereoModel.fromCameraInfo(self.leftInfo, self.rightInfo)
        (x,y,z) = stereoModel.projectPixelTo3d((u,v), disparity)
        return (x,y,z)

##############################
#      EXECUTION CODE        #
##############################

def main():
    rospy.init_node('color_segmenter')
    left_camera = 'left'
    right_camera = 'right'
    gs = ColorSegmenter(left_camera, right_camera)
    rospy.spin()


if __name__ == '__main__':
    main()


